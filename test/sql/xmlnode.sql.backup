-- The extension should be created in 'xmlnode' schema (use CREATE EXTENSION ... WITH SCHEMA ...) so that the functions like 'xpath()'
-- are not mixed with those implemented in Postgres core (libxml2).

SET search_path TO xmlnode;

CREATE TABLE STATES ( 
	id int not null,
	data xmldoc not null
);

CREATE TABLE PATHS (
	id int,
	name varchar(32),
	path xpath not null
);

CREATE TABLE DOCS_OTHER (
	id int,
	data xmldoc not null
);

-- Random geografic data
-- Czech and German languages are both good to test handling of multi-byte characters

INSERT INTO STATES VALUES(1,  '<?xml version="1.0" encoding="UTF-8"?>
	<state name="Česká republika" area="78866" population="10674947" tld="cz">
	<!-- Resource: http://en.wikipedia.org/wiki/Czech_Republic -->
	<city name="Praha" capital="true"/>
	<city name="Plzeň"><part name="Doubravka"/></city>
	<city name="Čerčany"/>
	<region name="Šumava"><destination name="Lipno"><![CDATA[http://en.wikipedia.org/wiki/Lipno_Dam]]></destination></region>
	<languages><language>Cestina</language></languages>
</state>');

INSERT INTO STATES VALUES(2,  '<?xml version="1.0" encoding="UTF-8"?><state name="Bundesrepublik Deutschland" area="357021" population="81757600" tld="de">
	<!-- Resource: http://en.wikipedia.org/wiki/Deutschland -->
	<city name="Berlin" capital="true"/>
	<region name="Baden-Württemberg"><city name="Stuttgart" capital="true"/></region>
	<region name="Bayern"><city name="Munchen" capital="true"/></region>
	<region name="Thüringen"><city name="Erfurt" capital="true"/></region>
	<languages><language official="true">Deutsch</language></languages>
</state>');

INSERT INTO STATES VALUES(3,  '<?xml version="1.0" encoding="UTF-8" ?><state name="Österreich" area="83872" population="8356707" tld="at">
	<!-- Resource: http://en.wikipedia.org/wiki/Oesterreich -->
	<city name="Wien" capital="true"/>
	<region name="Tirol"><city name="Innsbruck" capital="true"/></region>
	<region name="Steiermark"><city name="Graz" capital="true"/></region>
	<region name="Vorarlberg"><city name="Bregenz" capital="true"/></region>
	<languages><language official="true">Deutsch</language></languages>
</state>');

update states set data=xmlnode_add(data, '/state/languages', '<region name="Brandenburg"><city name="Potsdam" capital="true"/></region>', 'b') where id=2;
update states set data=xmlnode_add(data, '/state/languages', '<region name="Saarland" area="2569" population="1056000"/>', 'b') where id=2;
update states set data=xmlnode_add(data, '/state/region[@name="Saarland"]', '<city name="Saarbrücken" capital="true"/>', 'i') where id=2;
update states set data=xmlnode_add(data, '/state/region[@name="Saarland"]', '<city name="Ottweiler"/>', 'i') where id=2;
update states set data=xmlnode_add(data, '/state/region[@name="Saarland"]/city[@name="Saarbrücken"]', '<city name="Neunkirchen"/>', 'a') where id=2;


-- Simply dump the XML documents
select *
from states
order by id;


-- Query some XML paths 
select xpath('/state/@name', data) as state, xpath('/state/@tld', data) as domain,
xpath('/state/languages/language/text()', data) as language
from states
order by id;


-- Common table expression can be used to avoid parsing the xpath expression for each row
with paths(name, area, population)
as (select '/state/@name'::xpath, '/state/@area'::xpath, '/state/@population'::xpath)
select  id, xpath(p.name, data) as name, xpath(p.area, data) as area,
xpath(p.population, data) as population
from states s, paths p
order by s.id;

-- The XML path expressions can also be parsed (preprocessed) and stored into a table for later use...
insert into paths (name, path) values ('names', '/state/@name'), ('capitals', '/state/city[@capital="true"]/@name'), ('regions', '/state/region'), ('region_capitals', '/region/city[@capital="true"]/@name');

-- ... and used
select xpath(pn.path, s.data) as name, xpath(pc.path, s.data) as capital
from states s
join paths pn on (pn.name='names') 
join paths pc on (pc.name='capitals')
order by s.id;


select s.id, xpath(p.path, data)
from states s
join paths p on (p.name='regions')
order by s.id;


-- Convert data to table-like form
select id, xpath('/state', '{"region/city", "@area", "@population", "@tld"}', data) as state_info
from states
order by id;

-- Replace node
update states set data=xmlnode_add(data, '/state/region[@name="Šumava"]/destination', '<destination name="Boubín"/>', 'r') where id=1;

-- Add document fragment
-- before:
update states set data=xmlnode_add(data, '/state/languages', '<city name="České Budějovice" population="95071"/><city name="Kroměříž"/>', 'b') where id=1;
-- after:
 update states set data=xmlnode_add(data, '/state/city[@name="Praha"]', '<city name="Uherské Hradiště"/><city name="Františkovy Lázně"/>', 'a') where id=1;
-- into:
update states set data=xmlnode_add(data, '/state/city[@name="Praha"]', '<city name="Žižkov"/><city name="Břevnov"/>', 'i') where id=1;
-- into empty element (special case):
update states set data=xmlnode_add(data, '/state', '<people/>', 'i') where id=1;
update states set data=xmlnode_add(data, '/state/people', '<person first_name="Antonín" last_name="Dvořák"/><person first_name="Václav" last_name="Havel"/>', 'i') where id=1;
-- replace:
update states set data=xmlnode_add(data, '/state/languages/language', '<language official="true">Čeština</language><language>Hantec</language>', 'r') where id=1;

select data
from states
where id=1
order by id;

-- remove node:
update states set data=xmlnode_remove(data, '/state/city[@name="Kroměříž"]') where id=1;
-- ... and test if node will be correctly displayed as an empty element when the only child is removed:
update states set data=xmlnode_remove(data, '/state/city[@name="Plzeň"]/part[@name="Doubravka"]') where id=1;

select data
from states
where id=1
order by id;

-- xmlnode_remove() - repeated occurrence of the target path:
update states set data=xmlnode_remove(data, '/state/text()');

select data
from states
order by id;


-- Additional tests

-- xmlnode_add() - repeated occurrence of the target path:
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x>', 'b');
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x>', 'a');
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x>', 'r');
-- insert into both empty and non-empty element
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x>', 'i');
select xmlnode_add('<a><b><d/></b><b><d/></b></a>', '/a/b', '<x><y/></x>', 'i');
select xmlnode_add('<a><b id="1"/><b id="2"/></a>', '/a/b', '<x><y/></x>', 'i');
-- and the same for document fragment:
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x><!--no comment-->', 'b');
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x><!--no comment-->', 'a');
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x><!--no comment-->', 'r');
select xmlnode_add('<a><b/><b/></a>', '/a/b', '<x><y/></x><!--no comment-->', 'i');
select xmlnode_add('<a><b><d/></b><b><d/></b></a>', '/a/b', '<x><y/></x><!--no comment-->', 'i');
select xmlnode_add('<a><b id="1"/><b id="2"/></a>', '/a/b', '<x><y/></x><!--no comment-->', 'i');

-- xmlnode_remove() - repeated occurrence of the target path:
-- remove attribute
select xmlnode_remove('<a><b id="1" d="1"/><b id="2" d="2"/></a>', '/a/b/@id');
-- remove the last attribute
select xmlnode_remove('<a><b id="1"/><b id="2"/></a>', '/a/b/@id');
-- remove the last nested node(s)
select xmlnode_remove('<a><b/><b/></a>', '/a/b');

-- test the XPath parser
delete from paths;

insert into paths (id, path) values (0, '/c[@cd != @e != "a" and @b and @c or @f]/@g'),
(1, '/a[@a or @cd != @e != "a" and @b=@k=@l or @s]/b/text()'),
(2, '/state[@tld or "cz" = "cz" and @tld and @a or @b]'),
(3, '/state[@tld="de" or @area="78866" and @population="1067494"]'),
(4, '/a[(@b  != "a" and @k or @l)]/b/text()'),
(5, '/a[(@b  != "a" and (@k or @l))]/b/text()'),
(6, '/a[(( @cd and @e)  != "a" and @k)]/b[(@a > @c<=@g=@h)=i and @k=l]/text()'),
(7, '/a[@a or ((@e)  != "a" = @k or @l)]/b/text()'),
-- ... don't forget to use (predicate) subpaths
(8, '/a[ab/cd/@a!=b=c/a[@a=@b=a[@c and (@b or @c)]] = @a]'),
-- check if 'hasSubpaths' is propagated from subexpressions (both explicit and implicit)
(9, '/a[@a and @b or (@c=a[@e=@f])]'),
(10, '/a[@a and @b or (@c=a[@e=f])]'),
(11, '/a[@a and @b or @c=a[@e=@f]]'),
(12, '/a[@a and @b or @c=a[@e=f]]'),
-- Absolute sub-path
(13, '//root[/a and //b or c]'),
-- Functions
(14, '/root/a[position()=position()]'),
(15, '/root/b[count(a)>=count(c)]'),
(16, '/root[contains("", a)]');

select id, path
from paths
order by id asc;

select id, xpath_debug_print(path)
from paths
order by id asc;

-- some non-trivial XPath predicates
select xpath('/state[@tld="at" or @area="78866"]/@name', data) from states;
select xpath('/state[@tld="de" or @area="78866" and @population="0"]/@tld', data) from states;
select xpath('/state[@tld="de" or @area="78866" and @population="10674947"]/@tld', data) from states;
select xmlnode.xpath('/doc/a[(@b="1" or @b="2") and @c="3"]', '<doc><a b="1" c="2"/><a b="2" c="3"/></doc>');


-- MB characters in XPath expression
with paths(id, path) as (
values
((0), ('/dům/střecha'::xpath)),
((1), ('/dům/poschodí[@číslo="2"]'::xpath)),
((2), ('/dům/poschodí[@cislo="1"]'::xpath)),
((3), ('/dům/přízemí'::xpath))
)
select id, xpath(path, '<dům><střecha/><poschodí číslo="2"/><poschodí číslo="1"/><poschodi/><přízemí/><sklep/></dům>')
from paths
order by id;


-- subpaths

insert into docs_other(id, data)
values (1, '<root b="xxyy"><a>x<c/>y</a><b>x<c/>y</b></root>'), 
(2, '<root b="xxyy"><a>xx<c/>yy</a><b>x<c/></b></root>'),
(3, '<root><a i="1">x<c/>y1<d>z1<e/>z2</d>y2</a><b>x<c/>y</b><b i="1"></b></root>');

select id, xpath('/root[a!=@b]', data)
from docs_other
order by id;

select id, xpath('/root[a=@b]', data)
from docs_other
order by id;

select id, xpath('/root[b="xy"]', data)
from docs_other
order by id;

-- check that descendant text nodes are concantenated and compared correctly
select id, xpath('/root[a="xy1z1z2y2"]', data)
from docs_other
order by id;

select id, xpath('/root[a="xy1z1z2y"]', data)
from docs_other
order by id;

select id, xpath('/root[a="xy1z1z2y23"]', data)
from docs_other
order by id;

-- compare non-empty node set to zero-length literal

select id, xpath('/root[a=""]', data)
from docs_other
order by id;

select id, xpath('/root[a!=""]', data)
from docs_other
order by id;

-- compare non-empty node set, having no text nodes, to zero-length literal

select id, xpath('/root[b=""]', data)
from docs_other
order by id;

select id, xpath('/root[b!=""]', data)
from docs_other
order by id;

-- compare empty node set to zero-length literal

select id, xpath('/root[f=""]', data)
from docs_other
order by id;

select id, xpath('/root[f!=""]', data)
from docs_other
order by id;

-- compare non-empty node, having no text nodes, set to non-zero-length literal

select id, xpath('/root[b="xy1z1z2y2"]', data)
from docs_other
order by id;

select id, xpath('/root[b!="xy1z1z2y2"]', data)
from docs_other
order by id;

-- compare empty node set to non-zero-length literal

select id, xpath('/root[f="xy1z1z2y2"]', data)
from docs_other
order by id;

select id, xpath('/root[f!="xy1z1z2y2"]', data)
from docs_other
order by id;

-- compare non-empty node set to null value (attribute that doesn't exist)

select id, xpath('/root[a=@t]', data)
from docs_other
order by id;

select id, xpath('/root[a!=@t]', data)
from docs_other
order by id;

-- compare non-empty node set, having no text nodes, to null value

select id, xpath('/root[b=@t]', data)
from docs_other
order by id;

select id, xpath('/root[b!=@t]', data)
from docs_other
order by id;

-- compare empty node set to null value

select id, xpath('/root[f=@t]', data)
from docs_other
order by id;

select id, xpath('/root[f!=@t]', data)
from docs_other
order by id;

-- compare string to a set of text nodes (only sets of elements tested so far)

select xpath('/root[@i=a/text()]', '<root i="x"><a>y</a></root>'::xmldoc);
select xpath('/root[@i!=a/text()]', '<root i="x"><a>x</a></root>'::xmldoc);
select xpath('/root[@i=a/text()]', '<root i="x"><a>x</a><a>y</a></root>'::xmldoc);
select xpath('/root[@i!=a/text()]', '<root i="x"><a>x</a><a>y</a></root>'::xmldoc);

-- compare 2 node sets
select xpath('/root[a=b]', '<root><a i="1"/><b i="1"/></root>'::xmldoc);
select xpath('/root[a=b]', '<root><a i="1">x1<c/>x2</a><b i="1">x1<c/>x2</b></root>'::xmldoc);
select xpath('/root[a=b]', '<root><a i="1">x1<c>y1<d>z1</d>y3</c>x2</a><b i="1">x1y1<c/>z1y3x2</b></root>'::xmldoc);
select xpath('/root[a=b]', '<root><a i="1">x1<c>y1<d>z1</d>y3</c>x2x3</a><b i="1">x1y1<c/>z1y3x2</b></root>'::xmldoc);
select xpath('/root[a=b]', '<root><a i="1">x1</a><a i="2">x2</a><b i="1">x2</b></root>'::xmldoc);
select xpath('/root[a!=b]', '<root><a i="1">x1</a><a i="2">x2</a><b i="1">x2</b></root>'::xmldoc);
-- non-existing subpaths
select xpath('/root[a=a/b]', '<root i="x"><a>y</a></root>'::xmldoc);
select xpath('/root[a!=a/b]', '<root i="x"><a>y</a></root>'::xmldoc);

-- again, test sets of other than element nodes
select xpath('/root[a=a/@a]', '<root i="x"><a a="y">y</a></root>'::xmldoc);
select xpath('/root[a!=a/@a]', '<root i="x"><a a="y">y</a></root>'::xmldoc);
select xpath('/root[a!=a/@*]', '<root><a a="x" b="y">x</a></root>'::xmldoc);
select xpath('/root[a/@*=a]', '<root><a a="x" b="y">x</a></root>'::xmldoc);
select xpath('/root[a=comment()]', '<root><a>x</a><!--x--></root>'::xmldoc);
select xpath('/root[a!=comment()]', '<root><a>x</a><!--x--></root>'::xmldoc);
select xpath('/root[a=b/node()]', '<root><a>x</a><b><![CDATA[y]]></b></root>'::xmldoc);
select xpath('/root[a!=b/node()]', '<root><a>x</a><b><![CDATA[y]]></b></root>'::xmldoc);
select xpath('/root[a=b/processing-instruction("abc")]', '<root><a>def</a><b><?abc def?></b></root>'::xmldoc);
select xpath('/root[a!=b/processing-instruction("abc")]', '<root><a>def</a><b><?abc def?></b></root>'::xmldoc);

-- sets where non-element is on both sides
select xpath('/root[node()=node()]', '<root><![CDATA[x]]></root>'::xmldoc);
select xpath('/root[node()!=node()]', '<root><!--x--></root>'::xmldoc);

-- attributes having numeric values
select xpath('/root[@b=1.5 and @c=1.1000000]', '<root b="1.50" c="1.1"/>'::xmldoc);
select xpath('/root[@b!=1.5]', '<root b="1.50" c="1.1"/>'::xmldoc);

-- Compare number to a node-set. First, set of elements...
select xpath('/root[b=0.1]', '<root><b> 0.<c/>1<d/> </b></root>'::xmldoc);
select xpath('/root[b!=0.1]', '<root><b> 0.<c/>1<d/> </b></root>'::xmldoc);
-- ... and then also that of another type:
select xpath('/root[comment()=1.551]', '<root><!-- 1.5510 --></root>'::xmldoc);
select xpath('/root[comment()=1.551]', '<root><!----></root>'::xmldoc);
select xpath('/root[comment()!=1.551]', '<root><!----></root>'::xmldoc);

-- Operators '<' and '>'
select xpath('/root[@b>1.01]', '<root b="1.1"/>'::xmldoc);
select xpath('/root[@b<1.01]', '<root b="1.1"/>'::xmldoc);
select xpath('/root[1.01<@b]', '<root b="1.1"/>'::xmldoc);
select xpath('/root[1.01>@b]', '<root b="1.1"/>'::xmldoc);
select xpath('/root[b<1]', '<root><b>1.5</b></root>'::xmldoc);
select xpath('/root[b>1]', '<root><b>1.5</b></root>'::xmldoc);
select xpath('/root[1<b]', '<root><b>1.5</b></root>'::xmldoc);
select xpath('/root[1>b]', '<root><b>1.5</b></root>'::xmldoc);
-- No match if one operand can't be cast to a number:
select xpath('/root[@b>1.1]', '<root b="1.o1"><b/></root>'::xmldoc);
select xpath('/root[@b<1.1]', '<root b="1.o1"><b/></root>'::xmldoc);
select xpath('/root[@b<"a"]', '<root b="1.1"><b/></root>'::xmldoc);
select xpath('/root[@b>"a"]', '<root b="1.1"><b/></root>'::xmldoc);
select xpath('/root[@b>b]', '<root b="abc"><b>def</b></root>'::xmldoc);
select xpath('/root[@b<b]', '<root b="abc"><b>def</b></root>'::xmldoc);

-- The XPath predicate can be used even if the element has no children/attributes
select xmlnode.xpath('/root["a"]', '<root/>');
select xmlnode.xpath('/root[@a or a]', '<root/>');

-- Absolute sub-path
select xpath('/root[/root/a=x]', '<root><a>c</a><x>c</x></root>'::xmldoc);
select xpath('/root[/root/a=/x]', '<root><a>c</a><x>c</x></root>'::xmldoc);
select xpath('/root[//a=x]', '<root><a>c</a><x>c</x></root>'::xmldoc);
-- Special case: the sub-path represents the whole document:
select xpath('/root[/=/]', '<root/>'::xmldoc);
select xpath('/root[/!=/]', '<root/>'::xmldoc);
select xpath('/root[/=1]', '<root/>'::xmldoc);
select xpath('/root[/>1]', '<root/>'::xmldoc);
select xpath('/root[/=a]', '<root><a/></root>'::xmldoc);
select xpath('/root[/!=a]', '<root><a/></root>'::xmldoc);

-- position() function
select xpath('/root/a[position()=@i]', '<root><a i="2"/><a i="1"/><a i="3.0"/></root>'::xmldoc);
select xpath('/root/a[position()=1 or position()=2]', '<root><a i="1"/><a i="2"/></root>'::xmldoc); 
select xpath('/state/city[6]/@name', data) from states where id=1;
select xpath('/state/region[5]/city[1]/@name', data) from states where id=2;

select id, xpath('/state/comment()', data)
from states
order by id;

-- node() test: verify that only non-attribute child nodes are returned
select xmlnode.xpath('/a/node()', '<a i="1" j="2"><b/><c/><d i="1"/><e j="2"/><!--no comment--></a>');

-- all attributes but no other nodes
select xmlnode.xpath('/a/@*', '<a i="1" j="2" k="3"><b/><c/><d i="4"/><e j="5"/></a>');

-- descendants
select xmlnode.xpath('/a//b', '<a><b/><x><b i="3"/><a><b i="2"/></a></x></a>');
select xmlnode.xpath('//x/b', '<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>');
-- special case: with 2 location steps searching for descendants, some nodes may be found multiple times (by various combinations
-- of scan and its sub-scan). In this case that would happen for '<b><test2/></b>' if uniqueness wasn't enforced:
select xmlnode.xpath('//x//b', '<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>'::xmldoc);

-- Similarly, write functions using the descendant axe...
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x/b', '<new/>', 'r');
select xmlnode_add('<root><x><c><test1/><x><b><test2/></b></x></c><a><b><test3/></b><d/></a></x></root>', '/root//x/b', '<new/>', 'b');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x/b', '<new/>', 'a');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x//b', '<new/>', 'r');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x//b', '<new/>', 'a');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '//x//b', '<new/>', 'r');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '//x//b', '<new/>', 'a');
select xmlnode_add('<root><x><c><test1/><x><b><test2/></b></x></c><a><b><test3/></b><d/></a></x></root>', '/root//x/b', '<new/>', 'i');

select xmlnode_remove('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root/x/b');
select xmlnode_remove('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x/b');
select xmlnode_remove('<root><x><c><test1/><x><b><test2/></b></x></c><a><b><test3/></b><d/></a></x></root>', '/root//x/b');
select xmlnode_remove('<root><x><c><test1/><b><test2/></b></c><a><b><test3/></b><d/></a><b/></x></root>', '/root//x//b'); 
select xmlnode_remove('<root><x><c><test1/><b><test2/></b></c><a><b><test3/></b><d/></a><b/><b/></x></root>', '/root//x//b');
select xmlnode_remove('<root><x><c><test1/><b><test2/></b></c><a><b><test3/></b><d/></a><b i="1"/><b/></x></root>', '/root//x//b');
select xmlnode_remove('<root><x><c><test1/><b><test2/></b></c><a><b><test3/></b><d/></a><b i="1"/><b i="2"/></x></root>', '/root//x//b');
select xmlnode_remove('<root><x><c><test1/><b><test2/></b></c><a><b><test3/></b><d/></a><b><c/></b><b><c/></b></x></root>', '/root//x//b');
select xmlnode_remove('<a><b d="1" id="1" /><b d="2" id="2"/></a>', '/a/b//@id');
select xmlnode_remove('<a><b d="1" id="1" /><b d="2" id="2"/></a>', '//@id');
select xmlnode_remove('<a><b d="1" id="1" /><b d="2" id="2"/></a>', '//@*');

-- Specifically, addition must not take place multiple times for the same node. 
select xmlnode_add('<root><x><c><test1/><x><b><test2/></b></x></c><a><b><test3/></b><d/></a></x></root>', '/root//x//b', '<new/>', 'b');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '/root//x//b', '<new/>', 'i');
select xmlnode_add('<root><x><c><test1/><x><b><test2/></b></x></c><a><b><test3/></b><d/></a></x></root>', '//x//b', '<new/>', 'b');
select xmlnode_add('<root><x><b><test1/><x><b><test2/></b></x></b><a><b><test3/></b><d/></a></x></root>', '//x//b', '<new/>', 'i');
select xmlnode_add('<root><x><a/><b/><b><c/></b><x><b i="1"/></x><b/></x></root>', '/root//x//b', '<n/>', 'i');

-- Functions

select xpath('/root/b[count(a)>1]', '<root><a i="1"><b/></a><a i="2"><b/><b/></a></root>'::xmldoc);
select xpath('/root/b[count(c)=0]', '<root><a i="1"><b/></a><a i="2"><b/><b/></a></root>'::xmldoc);


select xpath('/root[contains(a, "x")]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains(a, "z")]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains(a, "")]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains("", a)]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains("", a)]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains(b, a)]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains(a, b)]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/root[contains(b, c)]', '<root><a>xy</a><a>z</a></root>'::xmldoc);
select xpath('/state[contains(@name, "rep") and (@area<=100000 or @population>11000000)]', '{@name, @area, @population}', data) 
from states
order by id;

select id, xpath('count(/state/region)', data)
from states
order by id;

-- Cleanup

drop table states;
drop table paths;
drop table docs_other;

